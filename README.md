# üó°Ô∏è CLAYMORE

A library that writes an hilt module for a requested interface implementation.

## üé¨ Scenario
Prerequisite: project using [Hilt](https://dagger.dev/hilt/) for dependencies injection.

In a typical use case, you have:
```
interface MyInterface

---

class MyImplementation @Inject constructor() : MyInterface

```

and you need to write a simple module only to bind the right implementation:
```
@Module
@InstallIn(SingletonComponent::class)
interface MyModule {
  @Binds
  fun binding(impl: MyImplementation): MyInterface
}
```

## üßô Annotation
With _claymore_ you can avoid to manually write that `Module`, by using `@AutoBinds` annotation:
```
@AutoBinds
class MyImplementation: MyInterface
```

_clamyore_ will automatically generate the necessary module for you.

### Component
You can optionally request _claymore_ to install the binding in a specific hilt component, using the `component` parameter.
```
@AutoBinds(component = ActivityComponent::class)
class MyImplementation: MyInterface
```
If not set, the `SingletonComponent` will be used by default.

### Annotations support
You can also request _claymore_ to attach any annotation to the binding method, using the `annotations` parameter.
```
@AutoBinds(annotations = [IntoSet::class])
class MyImplementation: MyInterface

// generates a module with a binding function like

@Binds
@IntoSet
fun binding(impl: MyImplementation): MyInterface
```

### AutoUninstall annotation
When in tests you need to uninstall module generated by `AutoBinds` annotation and so replace real implementations with fakes,
you can avoid to reference module generated by _claymore_ using the `AutoUninstall` annotation instead.
```
@AutoUninstall(
  implementations = [
    MyImplementation::class,
    MyOtherImplementation::class,
  ]
)
@InstallIn(SingletonComponent::class)
@Module
object TestModule {
  @Provides
  fun fakeImplementation(): MyInterface = FakeImplementation()
  
  @Provides
  fun otherFakeImplementation(): MyOtherInterface = OtherFakeImplementation()  
}
```
_claymore_ will generate a module that replaces generated `MyImplementationModule` and `MyOtherImplementationModule` for you.
Again, you can set the component where replace the modules, otherwise `SingletonComponent` is used by default.

## üéÆ Demo
Take a look at the `:demo` module for a [sample usage](https://github.com/alecarnevale/claymore/tree/master/demo).

In this simple project we have:
- `api` module where a single service (interface) lives;
- `impl` module where the service implementation is defined, and annotated with `AutoBinds`;
- `app` module where DI starts and service is requested.

Moreover the `annotations` module define other services to show the usage of `AutoBinds.annotations` parameter.

In the `annotations` module the `AutoUninstall` annotation is used in the test source set to replace the implementations with fakes
without referencing the generated modules.

## üõ†Ô∏è Installation

### Download
Claymore is available in Maven Central Repository:
- [annotations](https://central.sonatype.com/artifact/io.github.alecarnevale/claymore-annotations/1.3.2)
- [processors](https://central.sonatype.com/artifact/io.github.alecarnevale/claymore-processors/1.3.2)

### Gradle
```
repositories {
  mavenCentral()
}

dependencies {
  compileOnly 'io.github.alecarnevale:claymore-annotations:x.y.z'
}
```

### KSP integration
In order to completely enable `claymore` integration you need to apply the ksp plugin

```
plugins {
  id 'com.google.devtools.ksp'
}

dependencies {
  ksp 'io.github.alecarnevale:claymore-processors:x.y.z'
}
```

## üôè Thanks to
- KotlinPoet https://github.com/square/kotlinpoet
