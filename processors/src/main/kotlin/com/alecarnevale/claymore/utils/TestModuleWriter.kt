package com.alecarnevale.claymore.utils

import com.alecarnevale.claymore.annotations.AutoBinds
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toClassName

/**
 * Write a hilt module that uninstall the module generated by [AutoBinds],
 * when [AutoBinds] annotation is applied to the [implementationsDeclaration] provided.
 * The new test module will be installed in [components].
 */
internal class TestModuleWriter(
  private val name: String,
  private val packageName: String,
  private val components: List<KSClassDeclaration>,
  private val implementationsDeclaration: List<KSClassDeclaration>,
) {

  fun write(): FileSpec {
    val fileSpec = FileSpec.builder(
      packageName = packageName,
      fileName = name,
    )

    return fileSpec.addType(
      TypeSpec
        .objectBuilder(name)
        .addModifiers(KModifier.INTERNAL)
        .addAnnotation(moduleAnnotation)
        .addAnnotation(
          AnnotationSpec
            .builder(ClassName(packageName = "dagger.hilt.testing", "TestInstallIn"))
            .apply {
              val componentsClassArray = components.joinToString(separator = ", ") { component ->
                "${component.toClassName()}::class"
              }
              addMember(CodeBlock.of("components = [%L]", componentsClassArray))

              val implementationsClassArray =
                implementationsDeclaration.joinToString(separator = ", ") { impl ->
                  "${impl.retrieveModuleClassName()}::class"
                }
              addMember(CodeBlock.of("replaces = [%L]", implementationsClassArray))
            }
            .build()
        )
        .build()
    ).build()
  }
}